import markdown as md
import re
import html5lib
from html5lib import sanitizer
from django import template
from django.utils.safestring import mark_safe
from django.contrib.contenttypes.models import ContentType
from django.utils.encoding import force_text
import string as python_string

register = template.Library()


@register.filter(is_safe=True)
def markdown(value, arg=''):
    """
    Runs Markdown over a given value, optionally using various
    extensions python-markdown supports.

    Syntax::

        {{ value|markdown:"extension1_name,extension2_name..." }}

    To enable safe mode, which strips raw HTML and only returns HTML
    generated by actual Markdown syntax, pass "safe" as the first
    extension in the list.

    If the version of Markdown in use does not support extensions,
    they will be silently ignored.

    """
    extensions = [e for e in arg.split(",") if e]
    if extensions and extensions[0] == "safe":
        extensions = extensions[1:]
        return mark_safe(md.markdown(
            force_text(value), extensions, safe_mode=True, enable_attributes=False))
    else:
        return mark_safe(md.markdown(
            force_text(value), extensions, safe_mode=False))


@register.filter
def sanitize(value):
    p = html5lib.HTMLParser(tokenizer=sanitizer.HTMLSanitizer)
    return mark_safe(p.parseFragment(value).toxml())


@register.filter
def replace_regexp(string, args):
    search = args.split(args[0])[1]
    replace = args.split(args[0])[2]

    return re.sub(search, replace, string)


@register.filter
def replace(string, args):
    search = args.split(args[0])[1]
    replace = args.split(args[0])[2]

    return python_string.replace(string, search, replace)


@register.filter
def no_follow(string):
    r_nofollow = re.compile('<a (?![^>]*nofollow)')
    s_nofollow = '<a rel="nofollow" '

    return r_nofollow.sub(s_nofollow, string)


@register.filter
def app_name(obj):
    return ContentType.objects.get_for_model(obj.__class__).app_label
