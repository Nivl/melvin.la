// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package dbpublic

import (
	"context"
	"net/netip"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const adminGetBlogPost = `-- name: AdminGetBlogPost :one
SELECT id, title, slug, thumbnail_url, description, content_json, published_at, created_at, updated_at, deleted_at FROM blog_posts
WHERE
    deleted_at IS NULL
    AND id = $1
LIMIT 1
`

func (q *Queries) AdminGetBlogPost(ctx context.Context, id uuid.UUID) (*BlogPost, error) {
	row := q.db.QueryRow(ctx, adminGetBlogPost, id)
	var i BlogPost
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.ThumbnailURL,
		&i.Description,
		&i.ContentJSON,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const adminGetBlogPosts = `-- name: AdminGetBlogPosts :many
SELECT id, title, slug, thumbnail_url, description, content_json, published_at, created_at, updated_at, deleted_at FROM blog_posts
WHERE
    deleted_at IS NULL
    AND (CASE WHEN $1::bool THEN created_at < $2 ELSE TRUE END)
    AND (CASE WHEN $3::bool THEN created_at > $4 ELSE TRUE END)
ORDER BY
    CASE WHEN $3::varchar = 'asc' THEN created_at END ASC,
    CASE WHEN $1::varchar = 'desc' THEN created_at END DESC
LIMIT 100
`

type AdminGetBlogPostsParams struct {
	IsBefore   bool               `db:"is_before"`
	BeforeDate pgtype.Timestamptz `db:"before_date"`
	IsAfter    bool               `db:"is_after"`
	AfterDate  pgtype.Timestamptz `db:"after_date"`
}

func (q *Queries) AdminGetBlogPosts(ctx context.Context, arg AdminGetBlogPostsParams) ([]*BlogPost, error) {
	rows, err := q.db.Query(ctx, adminGetBlogPosts,
		arg.IsBefore,
		arg.BeforeDate,
		arg.IsAfter,
		arg.AfterDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*BlogPost
	for rows.Next() {
		var i BlogPost
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.ThumbnailURL,
			&i.Description,
			&i.ContentJSON,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteBlogPost = `-- name: DeleteBlogPost :exec
UPDATE blog_posts
    SET deleted_at = NOW()
WHERE
    id=$1
`

func (q *Queries) DeleteBlogPost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteBlogPost, id)
	return err
}

const deleteUserSession = `-- name: DeleteUserSession :exec
UPDATE user_sessions
    SET deleted_at = NOW()
WHERE
    token=$1
`

func (q *Queries) DeleteUserSession(ctx context.Context, token uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserSession, token)
	return err
}

const getPublishedBlogPost = `-- name: GetPublishedBlogPost :one
SELECT id, title, slug, thumbnail_url, description, content_json, published_at, created_at, updated_at, deleted_at FROM blog_posts
WHERE
    deleted_at IS NULL
    AND published_at IS NOT NULL
    AND slug = $1
LIMIT 1
`

func (q *Queries) GetPublishedBlogPost(ctx context.Context, slug string) (*BlogPost, error) {
	row := q.db.QueryRow(ctx, getPublishedBlogPost, slug)
	var i BlogPost
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.ThumbnailURL,
		&i.Description,
		&i.ContentJSON,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getPublishedBlogPosts = `-- name: GetPublishedBlogPosts :many
SELECT id, title, slug, thumbnail_url, description, content_json, published_at, created_at, updated_at, deleted_at FROM blog_posts
WHERE
    deleted_at IS NULL
    AND published_at IS NOT NULL
    AND (CASE WHEN $1::bool THEN published_at < $2 ELSE TRUE END)
    AND (CASE WHEN $3::bool THEN published_at > $4 ELSE TRUE END)
ORDER BY
    CASE WHEN $3::varchar = 'asc' THEN published_at END ASC,
    CASE WHEN $1::varchar = 'desc' THEN published_at END DESC
LIMIT 100
`

type GetPublishedBlogPostsParams struct {
	IsBefore   bool               `db:"is_before"`
	BeforeDate pgtype.Timestamptz `db:"before_date"`
	IsAfter    bool               `db:"is_after"`
	AfterDate  pgtype.Timestamptz `db:"after_date"`
}

func (q *Queries) GetPublishedBlogPosts(ctx context.Context, arg GetPublishedBlogPostsParams) ([]*BlogPost, error) {
	rows, err := q.db.Query(ctx, getPublishedBlogPosts,
		arg.IsBefore,
		arg.BeforeDate,
		arg.IsAfter,
		arg.AfterDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*BlogPost
	for rows.Next() {
		var i BlogPost
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.ThumbnailURL,
			&i.Description,
			&i.ContentJSON,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password, password_crypto, name, created_at, updated_at, deleted_at
FROM users
WHERE
    email=$1
    AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.PasswordCrypto,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

type InsertUserParams struct {
	ID             uuid.UUID `db:"id"`
	Name           string    `db:"name"`
	Email          string    `db:"email"`
	Password       string    `db:"password"`
	PasswordCrypto string    `db:"password_crypto"`
}

const insertUserSession = `-- name: InsertUserSession :one
INSERT INTO user_sessions
    (token, user_id, refresh_token, expires_at, ip_address)
VALUES
    ($1, $2, $3, $4, $5)
RETURNING token, user_id, created_at, updated_at, deleted_at, refresh_token, expires_at, refreshed_as, ip_address
`

type InsertUserSessionParams struct {
	Token        uuid.UUID          `db:"token"`
	UserID       uuid.UUID          `db:"user_id"`
	RefreshToken uuid.UUID          `db:"refresh_token"`
	ExpiresAt    pgtype.Timestamptz `db:"expires_at"`
	IPAddress    *netip.Prefix      `db:"ip_address"`
}

func (q *Queries) InsertUserSession(ctx context.Context, arg InsertUserSessionParams) (*UserSession, error) {
	row := q.db.QueryRow(ctx, insertUserSession,
		arg.Token,
		arg.UserID,
		arg.RefreshToken,
		arg.ExpiresAt,
		arg.IPAddress,
	)
	var i UserSession
	err := row.Scan(
		&i.Token,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.RefreshedAs,
		&i.IPAddress,
	)
	return &i, err
}
