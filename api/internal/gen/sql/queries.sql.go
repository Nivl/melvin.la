// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package dbpublic

import (
	"context"
	"net/netip"

	blog "github.com/Nivl/melvin.la/api/internal/services/blog"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const adminGetBlogPost = `-- name: AdminGetBlogPost :one
SELECT id, title, slug, thumbnail_url, description, content_json, published_at, created_at, updated_at, deleted_at FROM blog_posts
WHERE
    deleted_at IS NULL
    AND id = $1
LIMIT 1
`

func (q *Queries) AdminGetBlogPost(ctx context.Context, id uuid.UUID) (*BlogPost, error) {
	row := q.db.QueryRow(ctx, adminGetBlogPost, id)
	var i BlogPost
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.ThumbnailURL,
		&i.Description,
		&i.ContentJSON,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const adminGetBlogPosts = `-- name: AdminGetBlogPosts :many
SELECT id, title, slug, thumbnail_url, description, content_json, published_at, created_at, updated_at, deleted_at FROM blog_posts
WHERE
    deleted_at IS NULL
    AND (CASE WHEN $1::bool THEN created_at < $2 ELSE TRUE END)
    AND (CASE WHEN $3::bool THEN created_at > $4 ELSE TRUE END)
ORDER BY
    CASE WHEN $3::varchar = 'asc' THEN created_at END ASC,
    CASE WHEN $1::varchar = 'desc' THEN created_at END DESC
LIMIT 100
`

type AdminGetBlogPostsParams struct {
	IsBefore   bool               `db:"is_before"`
	BeforeDate pgtype.Timestamptz `db:"before_date"`
	IsAfter    bool               `db:"is_after"`
	AfterDate  pgtype.Timestamptz `db:"after_date"`
}

func (q *Queries) AdminGetBlogPosts(ctx context.Context, arg AdminGetBlogPostsParams) ([]*BlogPost, error) {
	rows, err := q.db.Query(ctx, adminGetBlogPosts,
		arg.IsBefore,
		arg.BeforeDate,
		arg.IsAfter,
		arg.AfterDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*BlogPost
	for rows.Next() {
		var i BlogPost
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.ThumbnailURL,
			&i.Description,
			&i.ContentJSON,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteBlogPost = `-- name: DeleteBlogPost :exec
UPDATE blog_posts
    SET deleted_at = NOW()
WHERE
    id=$1
`

func (q *Queries) DeleteBlogPost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteBlogPost, id)
	return err
}

const deleteUserSession = `-- name: DeleteUserSession :exec
UPDATE user_sessions
    SET deleted_at = NOW()
WHERE
    token=$1
`

func (q *Queries) DeleteUserSession(ctx context.Context, token uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserSession, token)
	return err
}

const getBlogPostForUpdate = `-- name: GetBlogPostForUpdate :one
SELECT id, title, slug, thumbnail_url, description, content_json, published_at, created_at, updated_at, deleted_at FROM blog_posts
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetBlogPostForUpdate(ctx context.Context, id uuid.UUID) (*BlogPost, error) {
	row := q.db.QueryRow(ctx, getBlogPostForUpdate, id)
	var i BlogPost
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.ThumbnailURL,
		&i.Description,
		&i.ContentJSON,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getPublishedBlogPost = `-- name: GetPublishedBlogPost :one
SELECT id, title, slug, thumbnail_url, description, content_json, published_at, created_at, updated_at, deleted_at FROM blog_posts
WHERE
    deleted_at IS NULL
    AND published_at IS NOT NULL
    AND slug = $1
LIMIT 1
`

func (q *Queries) GetPublishedBlogPost(ctx context.Context, slug string) (*BlogPost, error) {
	row := q.db.QueryRow(ctx, getPublishedBlogPost, slug)
	var i BlogPost
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.ThumbnailURL,
		&i.Description,
		&i.ContentJSON,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getPublishedBlogPosts = `-- name: GetPublishedBlogPosts :many
SELECT id, title, slug, thumbnail_url, description, content_json, published_at, created_at, updated_at, deleted_at FROM blog_posts
WHERE
    deleted_at IS NULL
    AND published_at IS NOT NULL
    AND (CASE WHEN $1::bool THEN published_at < $2 ELSE TRUE END)
    AND (CASE WHEN $3::bool THEN published_at > $4 ELSE TRUE END)
ORDER BY
    CASE WHEN $3::varchar = 'asc' THEN published_at END ASC,
    CASE WHEN $1::varchar = 'desc' THEN published_at END DESC
LIMIT 100
`

type GetPublishedBlogPostsParams struct {
	IsBefore   bool               `db:"is_before"`
	BeforeDate pgtype.Timestamptz `db:"before_date"`
	IsAfter    bool               `db:"is_after"`
	AfterDate  pgtype.Timestamptz `db:"after_date"`
}

func (q *Queries) GetPublishedBlogPosts(ctx context.Context, arg GetPublishedBlogPostsParams) ([]*BlogPost, error) {
	rows, err := q.db.Query(ctx, getPublishedBlogPosts,
		arg.IsBefore,
		arg.BeforeDate,
		arg.IsAfter,
		arg.AfterDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*BlogPost
	for rows.Next() {
		var i BlogPost
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.ThumbnailURL,
			&i.Description,
			&i.ContentJSON,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password, password_crypto, name, created_at, updated_at, deleted_at
FROM users
WHERE
    email=$1
    AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.PasswordCrypto,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getUserBySessionToken = `-- name: GetUserBySessionToken :one
SELECT u.id, u.email, u.password, u.password_crypto, u.name, u.created_at, u.updated_at, u.deleted_at
FROM users u
LEFT JOIN user_sessions us
    ON u.id = us.user_id
WHERE us.token=$1
    AND us.deleted_at IS NULL
    AND u.deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetUserBySessionToken(ctx context.Context, token uuid.UUID) (*User, error) {
	row := q.db.QueryRow(ctx, getUserBySessionToken, token)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.PasswordCrypto,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const insertBlogPost = `-- name: InsertBlogPost :one
INSERT INTO blog_posts
    (id, title, description, slug, thumbnail_url, content_json, published_at)
VALUES
    ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, title, slug, thumbnail_url, description, content_json, published_at, created_at, updated_at, deleted_at
`

type InsertBlogPostParams struct {
	ID           uuid.UUID           `db:"id"`
	Title        string              `db:"title"`
	Description  *string             `db:"description"`
	Slug         string              `db:"slug"`
	ThumbnailURL *string             `db:"thumbnail_url"`
	ContentJSON  blog.EditorJSOutput `db:"content_json"`
	PublishedAt  pgtype.Timestamptz  `db:"published_at"`
}

func (q *Queries) InsertBlogPost(ctx context.Context, arg InsertBlogPostParams) (*BlogPost, error) {
	row := q.db.QueryRow(ctx, insertBlogPost,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Slug,
		arg.ThumbnailURL,
		arg.ContentJSON,
		arg.PublishedAt,
	)
	var i BlogPost
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.ThumbnailURL,
		&i.Description,
		&i.ContentJSON,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const insertBlogPostRev = `-- name: InsertBlogPostRev :one
INSERT INTO blog_post_revs
    (id, blog_post_id, title, content_json, description, thumbnail_url, slug)
VALUES
    ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, blog_post_id, title, slug, thumbnail_url, description, content_json, created_at, deleted_at
`

type InsertBlogPostRevParams struct {
	ID           uuid.UUID           `db:"id"`
	BlogPostID   uuid.UUID           `db:"blog_post_id"`
	Title        string              `db:"title"`
	ContentJSON  blog.EditorJSOutput `db:"content_json"`
	Description  *string             `db:"description"`
	ThumbnailURL *string             `db:"thumbnail_url"`
	Slug         string              `db:"slug"`
}

func (q *Queries) InsertBlogPostRev(ctx context.Context, arg InsertBlogPostRevParams) (*BlogPostRev, error) {
	row := q.db.QueryRow(ctx, insertBlogPostRev,
		arg.ID,
		arg.BlogPostID,
		arg.Title,
		arg.ContentJSON,
		arg.Description,
		arg.ThumbnailURL,
		arg.Slug,
	)
	var i BlogPostRev
	err := row.Scan(
		&i.ID,
		&i.BlogPostID,
		&i.Title,
		&i.Slug,
		&i.ThumbnailURL,
		&i.Description,
		&i.ContentJSON,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

type InsertUserParams struct {
	ID             uuid.UUID `db:"id"`
	Name           string    `db:"name"`
	Email          string    `db:"email"`
	Password       string    `db:"password"`
	PasswordCrypto string    `db:"password_crypto"`
}

const insertUserSession = `-- name: InsertUserSession :one
INSERT INTO user_sessions
    (token, user_id, refresh_token, expires_at, ip_address)
VALUES
    ($1, $2, $3, $4, $5)
RETURNING token, user_id, created_at, updated_at, deleted_at, refresh_token, expires_at, refreshed_as, ip_address
`

type InsertUserSessionParams struct {
	Token        uuid.UUID          `db:"token"`
	UserID       uuid.UUID          `db:"user_id"`
	RefreshToken uuid.UUID          `db:"refresh_token"`
	ExpiresAt    pgtype.Timestamptz `db:"expires_at"`
	IPAddress    *netip.Prefix      `db:"ip_address"`
}

func (q *Queries) InsertUserSession(ctx context.Context, arg InsertUserSessionParams) (*UserSession, error) {
	row := q.db.QueryRow(ctx, insertUserSession,
		arg.Token,
		arg.UserID,
		arg.RefreshToken,
		arg.ExpiresAt,
		arg.IPAddress,
	)
	var i UserSession
	err := row.Scan(
		&i.Token,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.RefreshedAs,
		&i.IPAddress,
	)
	return &i, err
}

const updateBlogPost = `-- name: UpdateBlogPost :one
UPDATE blog_posts
SET
    title = $1,
    slug = $2,
    description = $3,
    thumbnail_url = $4,
    content_json = $5,
    published_at = $6,
    updated_at = NOW()
WHERE
    id = $7
RETURNING id, title, slug, thumbnail_url, description, content_json, published_at, created_at, updated_at, deleted_at
`

type UpdateBlogPostParams struct {
	Title        string              `db:"title"`
	Slug         string              `db:"slug"`
	Description  *string             `db:"description"`
	ThumbnailURL *string             `db:"thumbnail_url"`
	ContentJSON  blog.EditorJSOutput `db:"content_json"`
	PublishedAt  pgtype.Timestamptz  `db:"published_at"`
	ID           uuid.UUID           `db:"id"`
}

func (q *Queries) UpdateBlogPost(ctx context.Context, arg UpdateBlogPostParams) (*BlogPost, error) {
	row := q.db.QueryRow(ctx, updateBlogPost,
		arg.Title,
		arg.Slug,
		arg.Description,
		arg.ThumbnailURL,
		arg.ContentJSON,
		arg.PublishedAt,
		arg.ID,
	)
	var i BlogPost
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.ThumbnailURL,
		&i.Description,
		&i.ContentJSON,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
